package run_ffmpeg;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.logging.Logger;

import com.mongodb.client.MongoCollection;

import run_ffmpeg.ffmpeg.FFmpeg_ProbeResult;

/**
 * Problems to solve:
 * - Identify which movies/tv shows are missing subtitles
 * -- Build ffprobe for both input and output
 * --- Need means to record them
 * - Fix subtitles, audio, metadata for all items, if required
 * -- Need to know which are broken
 * -- Need to correlate those back to the MKV files and cross-check
 * - Build a method to update those movies/tv shows that are misconfigured or missing information
 * -- Use above database (?) of ffprobe data to analyze deltas
 * -- Update run_ffmpeg (or other) to fix those items using database inputs
 * @author Dan
 */
public class ExtractSubtitles extends run_ffmpegControllerThreadTemplate< ExtractSubtitlesWorkerThread >
{
	/// The list of folders to extract. Each entry into the top-level List is for a single thread.
	/// This structure will be initialized during object initialization and be populated by
	/// a single empty List< String >.
	private List< List< String > > foldersToExtractByThread = null ;

	/// Reference to a PD object to access its probeFileAndUpdateDB() method.
	/// Will be passed to the worker threads.
	/// Included here so only one instance of PD is created.
	private transient ProbeDirectories probeDirectories = null ;

	/// File name to which to log activities for this application.
	private static final String logFileName = "log_extract_pgs.txt" ;

	/// If the file by the given name is present, stop this processing at the
	/// next iteration of the main loop.
	private static final String stopFileName = "C:\\Temp\\stop_extract_subtitles.txt" ;

	/// The structure used to enable a transcode pipeline.
	/// transcodePipeline will hold the sup files generated by this class.
	/// If transcodePipeline is null, then the pipeline is not enabled and it is ignored.
	/// Access to transcodePipeline will be guarded with a synchronized block since it will be
	/// used in a threaded environment.
	private PriorityBlockingQueue< File > ocrFilePipeline = null ;

	/**
	 * Default constructor relies on the super class.
	 */
	public ExtractSubtitles()
	{
		super( logFileName, stopFileName ) ;
		initObject() ;
	}

	/**
	 * Constructor used primarily by external classes.
	 * @param log
	 * @param common
	 * @param masMDB
	 * @param probeInfoCollection
	 */
	public ExtractSubtitles( Logger log,
			Common common,
			MoviesAndShowsMongoDB masMDB,
			MongoCollection< FFmpeg_ProbeResult > probeInfoCollection )
	{
		super( log, common, stopFileName, masMDB, probeInfoCollection ) ;
		initObject() ;
	}

	public ExtractSubtitles( Logger log,
			Common common,
			final String stopFileName,
			MoviesAndShowsMongoDB masMDB,
			MongoCollection< FFmpeg_ProbeResult > probeInfoCollection )
	{
		super( log, common, stopFileName, masMDB, probeInfoCollection ) ;
		initObject() ;
	}

	/**
	 * Initialize this object.
	 */
	private void initObject()
	{
		probeDirectories = new ProbeDirectories( log, common, masMDB, probeInfoCollection ) ;
		foldersToExtractByThread = new ArrayList< List< String > >() ;
		foldersToExtractByThread.add( new ArrayList< String >() ) ;
	}

	public static void main(String[] args)
	{
		ExtractSubtitles extractSubtitles = new ExtractSubtitles() ;
		extractSubtitles.Init() ;
		extractSubtitles.Execute() ;
		System.out.println( "Process shut down." ) ;
	}

	/**
	 * Build the worker threads for this instance.
	 * Each thread will only receive the portion of the probeInfoMap related to its drive.
	 * Note that this means the drive prefixes must be mutually exclusive.
	 */
	@Override
	protected List< ExtractSubtitlesWorkerThread > buildWorkerThreads()
	{
		List< ExtractSubtitlesWorkerThread > threads = new ArrayList< ExtractSubtitlesWorkerThread >() ;

		for( List< String > foldersToExtractForThisThread : foldersToExtractByThread )
		{
			if( foldersToExtractForThisThread.isEmpty() )
			{
				log.warning( "Empty foldersToExtractForThisThread" ) ;
				continue ;
			}
			
			ExtractSubtitlesWorkerThread newWorkerThread = new ExtractSubtitlesWorkerThread(
					this,
					log,
					common,
					probeDirectories,
					foldersToExtractForThisThread ) ;
			newWorkerThread.setName( foldersToExtractForThisThread.get( 0 ) ) ;
			threads.add( newWorkerThread ) ;
		}

		return threads ;
	}

	/**
	 * Override the method called when execution begins.
	 */
	@Override
	public void Init()
	{
		setUseThreads( true ) ;
		common.setTestMode( false ) ;

		if( foldersToExtractIsEmpty() )
		{
			// This object is not in use by another class because the foldersToExtract is null.
			// Probably running via main() in this class.
			// Populate the structure here.
			boolean extractAllFolders = false ;
			if( extractAllFolders )
			{
				addFoldersToExtract( Common.getAllMediaFolders() ) ;
			}
			else
			{
				addFoldersToExtractWithNewThread( Arrays.asList( Common.getPathToToOCR() ) ) ;
			}
		}
	}
	
	protected void addFileToOCRPipeline( final File theFile )
	{
		if( null == ocrFilePipeline )
		{
			// Pipeline disabled.
			return ;
		}

		synchronized( ocrFilePipeline )
		{
			ocrFilePipeline.add( theFile ) ;
		}
	}

	protected void addFilesToOCRPipeline( final List< File > theFiles )
	{
		if( null == ocrFilePipeline )
		{
			// Pipeline disabled.
			return ;
		}

		synchronized( ocrFilePipeline )
		{
			ocrFilePipeline.addAll( theFiles ) ;
		}
	}

	/**
	 * Add one or more folders to extract to the default thread.
	 * @param foldersToAdd
	 */
	public void addFoldersToExtract( final List< String > foldersToAdd )
	{
		assert( foldersToAdd != null ) ;

		foldersToExtractByThread.get( 0 ).addAll( foldersToAdd ) ;
	}
	
	public void addFoldersToExtract( final String folderToAdd )
	{
		addFoldersToExtract( Arrays.asList( folderToAdd ) ) ;
	}

	/**
	 * Add one or more folders to extract to a new thread. Note that this may be the default thread if
	 *  no folders have already been assigned.
	 * @param foldersToAdd
	 */
	public void addFoldersToExtractWithNewThread( final List< String > foldersToAdd )
	{
		assert( foldersToAdd != null ) ;

		List< String > foldersToExtract = new ArrayList< String >() ;
		foldersToExtractByThread.add( foldersToExtract ) ;

		foldersToExtract.addAll( foldersToAdd ) ;
	}

	public void addFoldersToExtractWithNewThread( final String folderToAdd )
	{
		addFoldersToExtractWithNewThread( Arrays.asList( folderToAdd ) ) ;
	}
	
	public boolean foldersToExtractIsEmpty()
	{
		return foldersToExtractByThread.get( 0 ).isEmpty() ;
	}

	/**
	 * Return all folders that will be extracted. Includes folders from all threads.
	 * @return
	 */
	public List< String > getAllFoldersToExtract()
	{
		List< String > allFoldersToExtract = new ArrayList< String >() ;
		for( List< String > theFoldersToExtract : foldersToExtractByThread )
		{
			allFoldersToExtract.addAll( theFoldersToExtract ) ;
		}
		return allFoldersToExtract ;
	}
	
	/**
	 * Return the file at the front of the queue, or null if the queue is empty.
	 * @return
	 */
	protected File getOCRPipelineFile()
	{
		File retMe = null ;
		if( ocrFilePipeline != null )
		{
			synchronized( ocrFilePipeline )
			{
				retMe = ocrFilePipeline.poll() ;
			}
		}
		return retMe ;
	}

	protected boolean pipelineIsEmpty()
	{
		boolean isEmpty = true ;
		if( ocrFilePipeline != null )
		{
			synchronized( ocrFilePipeline )
			{
				isEmpty = ocrFilePipeline.isEmpty() ;
			}
		}
		return isEmpty ;
	}

	protected synchronized void setTranscodePipeline( PriorityBlockingQueue< File > transcodePipeline )
	{
		this.ocrFilePipeline = transcodePipeline;
	}
}
