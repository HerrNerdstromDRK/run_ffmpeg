package run_ffmpeg;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.logging.Logger;

import com.mongodb.client.MongoCollection;

/**
 * Problems to solve:
 * - Identify which movies/tv shows are missing MKVs
 * -- Build an inventory algorith to list all movies/tv shows
 * - Identify which movies/tv shows are missing subtitles
 * -- Build ffprobe for both input and output
 * --- Need means to record them
 * - Identify which movies/tv shows need forced subtitles
 * - Fix subtitles, audio, metadata for all items, if required
 * -- Need to know which are broken
 * -- Need to correlate those back to the MKV files and cross-check
 * - Build a method to update those movies/tv shows that are misconfigured or missing information
 * -- Use above database (?) of ffprobe data to analyze deltas
 * -- Update run_ffmpeg (or other) to fix those items using database inputs
 * @author Dan
 */
public class ExtractSubtitles extends run_ffmpegControllerThreadTemplate< ExtractSubtitlesWorkerThread >
{
	/// The list of drives and folders to extract.
	private List< String > foldersToExtract = null ;

	/// Reference to a PD object to access its probeFileAndUpdateDB() method.
	/// Will be passed to the worker threads.
	/// Included here so only one instance of PD is created.
	private transient ProbeDirectories probeDirectories = null ;

	/// File name to which to log activities for this application.
	private static final String logFileName = "log_extract_pgs.txt" ;

	/// If the file by the given name is present, stop this processing at the
	/// next iteration of the main loop.
	private static final String stopFileName = "C:\\Temp\\stop_extract_subtitles.txt" ;

	/// The structure used to enable a transcode pipeline.
	/// transcodePipeline will hold the sup files generated by this class.
	/// If transcodePipeline is null, then the pipeline is not enabled and it is ignored.
	/// Access to transcodePipeline will be guarded with a synchronized block since it will be
	/// used in a threaded environment.
	private PriorityBlockingQueue< File > filePipeline = null ;

	/**
	 * Default constructor relies on the super class.
	 */
	public ExtractSubtitles()
	{
		super( logFileName, stopFileName ) ;
		initObject() ;
	}
	
	/**
	 * Constructor used primarily by external classes.
	 * @param log
	 * @param common
	 * @param masMDB
	 * @param probeInfoCollection
	 */
	public ExtractSubtitles( Logger log,
			Common common,
			MoviesAndShowsMongoDB masMDB,
			MongoCollection< FFmpegProbeResult > probeInfoCollection )
	{
		super( log, common, stopFileName, masMDB, probeInfoCollection ) ;
		initObject() ;
	}

	public ExtractSubtitles( Logger log,
			Common common,
			final String stopFileName,
			MoviesAndShowsMongoDB masMDB,
			MongoCollection< FFmpegProbeResult > probeInfoCollection )
	{
		super( log, common, stopFileName, masMDB, probeInfoCollection ) ;
		initObject() ;
	}
	
	/**
	 * Initialize this object.
	 */
	private void initObject()
	{
		probeDirectories = new ProbeDirectories( log, common, masMDB, probeInfoCollection ) ;
	}

	public static void main(String[] args)
	{
		ExtractSubtitles extractSubtitles = new ExtractSubtitles() ;
		extractSubtitles.Init() ;
		extractSubtitles.Execute() ;
		System.out.println( "Process shut down." ) ;
	}

	/**
	 * Build the worker threads for this instance.
	 * Each thread will only receive the portion of the probeInfoMap related to its drive.
	 * Note that this means the drive prefixes must be mutually exclusive.
	 */
	@Override
	protected List< ExtractSubtitlesWorkerThread > buildWorkerThreads()
	{
		List< ExtractSubtitlesWorkerThread > threads = new ArrayList< ExtractSubtitlesWorkerThread >() ;

		if( isUseThreads() )
		{
			// The internal foldersToExtract structure identifies individual folders to extract, some of which may 
			// the same drive ("To Convert" and "To Convert - TV Shows" on the same drive), so assign
			// one drive per folder.
			// Breakdown each of the given folders by the drive to which they are assigned.
			// This structure consists of one list of folders per each drive. 
			Map< String, List< String > > foldersByDrive = Common.getDrivesAndFolders( foldersToExtract ) ;

			// Create a new thread for each drive.
			for( Map.Entry< String, List< String > > entrySet : foldersByDrive.entrySet() )
			{
				final String theDrive = entrySet.getKey() ;
				final List< String > foldersOnThisDrive = entrySet.getValue() ;

				ExtractSubtitlesWorkerThread newWorkerThread = new ExtractSubtitlesWorkerThread(
						this,
						log,
						common,
						probeDirectories,
						foldersOnThisDrive ) ;
				newWorkerThread.setName( theDrive ) ;
				threads.add( newWorkerThread ) ;
			}
		}
		else
		{
			// NOT using threads.
			// Just create a single thread instance and pass it the entire list of folders to extract.
			// Thread.start() will NOT be called -- just run() directly.
			ExtractSubtitlesWorkerThread newWorkerThread = new ExtractSubtitlesWorkerThread(
					this,
					log,
					common,
					probeDirectories,
					foldersToExtract ) ;
			newWorkerThread.setName( getSingleThreadedName() ) ;
			threads.add( newWorkerThread ) ;
		}
		return threads ;
	}

	/**
	 * Override the method called when execution begins.
	 */
	@Override
	public void Init()
	{
		setUseThreads( true ) ;
		common.setTestMode( false ) ;

		if( null == foldersToExtract )
		{
			// This object is not in use by another class because the foldersToExtract is null.
			// Populate the structure here.
			boolean extractAllFolders = false ;
			if( extractAllFolders )
			{
				foldersToExtract = common.addToConvertToEachDrive( common.getAllMKVDrives() ) ;
			}
			else
			{
				foldersToExtract = new ArrayList< String >() ;
				foldersToExtract.add( "C:\\Temp\\To OCR" ) ;
				foldersToExtract.add( "\\\\yoda\\MKV_Archive9\\To Convert\\Children Of Men (2006)" ) ;
				foldersToExtract.add( "\\\\yoda\\MKV_Archive9\\To Convert\\Daddys Home (2015)" ) ;
			}
		}
	}

	protected void addFileToPipeline( File theFile )
	{
		if( null == filePipeline )
		{
			// Pipeline disabled.
			return ;
		}
	
		synchronized( filePipeline )
		{
			filePipeline.add( theFile ) ;
		}
	}

	protected void addFilesToPipeline( List< File > theFiles )
	{
		if( null == filePipeline )
		{
			// Pipeline disabled.
			return ;
		}
	
		synchronized( filePipeline )
		{
			filePipeline.addAll( theFiles ) ;
		}
	}

	public void addFoldersToExtract( final List< String > foldersToAdd )
	{
		assert( foldersToAdd != null ) ;

		if( null == foldersToExtract )
		{
			foldersToExtract = new ArrayList< String >() ;
		}
		foldersToExtract.addAll( foldersToAdd ) ;
	}

	/**
	 * Return the file at the front of the queue, or null if the queue is empty.
	 * @return
	 */
	protected File getPipelineFile()
	{
		File retMe = null ;
		if( filePipeline != null )
		{
			synchronized( filePipeline )
			{
				retMe = filePipeline.poll() ;
			}
		}
		return retMe ;
	}

	protected boolean pipelineIsEmpty()
	{
		boolean isEmpty = true ;
		if( filePipeline != null )
		{
			synchronized( filePipeline )
			{
				isEmpty = filePipeline.isEmpty() ;
			}
		}
		return isEmpty ;
	}

	protected synchronized void setTranscodePipeline( PriorityBlockingQueue< File > transcodePipeline )
	{
		this.filePipeline = transcodePipeline;
	}
}
