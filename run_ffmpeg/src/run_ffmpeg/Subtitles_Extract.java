package run_ffmpeg;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.logging.Logger;

import com.mongodb.client.MongoCollection;

import run_ffmpeg.ffmpeg.FFmpeg_ProbeResult;

public class Subtitles_Extract extends run_ffmpegControllerThreadTemplate< Subtitles_ExtractWorkerThread >
{
	/// The list of folders to extract. Each entry into the top-level List is for a single thread.
	/// This structure will be initialized during object initialization and be populated by
	/// a single empty List< String >.
	private List< List< String > > foldersToExtractByThread = null ;

	/// Reference to a PD object to access its probeFileAndUpdateDB() method.
	/// Will be passed to the worker threads.
	/// Included here so only one instance of PD is created.
	private transient ProbeDirectories probeDirectories = null ;
	
	protected transient MoviesAndShowsMongoDB masMDB = null ;
	protected transient MongoCollection< FFmpeg_ProbeResult > createSRTCollection = null ;

	/// File name to which to log activities for this application.
	private static final String logFileName = "log_subtitles_extract.txt" ;

	/// If the file by the given name is present, stop this processing at the
	/// next iteration of the main loop.
	private static final String stopFileName = "C:\\Temp\\stop_subtitles_extract.txt" ;

	/// These structures are used to enable the OCR and AI transcription pipelines.
	/// ocrFilePipeline will hold the sup files generated by this class.
	/// transcriptionFilePipeline will hold wav files generated by this class.
	/// If ocrFilePipeline is null, then the pipeline is not enabled and it is ignored. Same for transcriptionFilePipeline.
	/// Access to these structures will be guarded with a synchronized block since they will be
	/// used in a threaded environment.
	private PriorityBlockingQueue< File > ocrFilePipeline = null ;
	private PriorityBlockingQueue< File > transcriptionFilePipeline = null ;

	/**
	 * Default constructor relies on the super class.
	 */
	public Subtitles_Extract()
	{
		super( logFileName, stopFileName ) ;
		initObject() ;
	}

	/**
	 * Constructor used primarily by external classes.
	 * @param log
	 * @param common
	 * @param masMDB
	 * @param probeInfoCollection
	 */
	public Subtitles_Extract( Logger log,
			Common common,
			MoviesAndShowsMongoDB masMDB,
			MongoCollection< FFmpeg_ProbeResult > probeInfoCollection )
	{
		super( log, common, stopFileName, masMDB, probeInfoCollection ) ;
		initObject() ;
	}

	public Subtitles_Extract( Logger log,
			Common common,
			final String stopFileName,
			MoviesAndShowsMongoDB masMDB,
			MongoCollection< FFmpeg_ProbeResult > probeInfoCollection )
	{
		super( log, common, stopFileName, masMDB, probeInfoCollection ) ;
		initObject() ;
	}

	/**
	 * Initialize this object.
	 */
	private void initObject()
	{
		probeDirectories = new ProbeDirectories( log, common, masMDB, probeInfoCollection ) ;
		foldersToExtractByThread = new ArrayList< List< String > >() ;
		foldersToExtractByThread.add( new ArrayList< String >() ) ;
		masMDB = new MoviesAndShowsMongoDB( log ) ;
		createSRTCollection = masMDB.getAction_CreateSRTsWithAICollection() ;
	}

	public static void main(String[] args)
	{
		Subtitles_Extract extractSubtitles = new Subtitles_Extract() ;
		extractSubtitles.Init() ;
		extractSubtitles.Execute() ;
		System.out.println( "Process shut down." ) ;
	}

	/**
	 * Build the worker threads for this instance.
	 * Each thread will only receive the portion of the probeInfoMap related to its drive.
	 * Note that this means the drive prefixes must be mutually exclusive.
	 */
	@Override
	protected List< Subtitles_ExtractWorkerThread > buildWorkerThreads()
	{
		List< Subtitles_ExtractWorkerThread > threads = new ArrayList< Subtitles_ExtractWorkerThread >() ;

		for( List< String > foldersToExtractForThisThread : foldersToExtractByThread )
		{
			if( foldersToExtractForThisThread.isEmpty() )
			{
				log.warning( getName() + " Empty foldersToExtractForThisThread" ) ;
				continue ;
			}
			
			Subtitles_ExtractWorkerThread newWorkerThread = new Subtitles_ExtractWorkerThread(
					this,
					log,
					common,
					probeDirectories,
					foldersToExtractForThisThread ) ;
			newWorkerThread.setName( foldersToExtractForThisThread.get( 0 ) ) ;
			threads.add( newWorkerThread ) ;
		}

		return threads ;
	}

	/**
	 * Override the method called when execution begins.
	 */
	@Override
	public void Init()
	{
		setUseThreads( true ) ;
		common.setTestMode( false ) ;

		if( foldersToExtractIsEmpty() )
		{
			// This object is not in use by another class because the foldersToExtract is null.
			// Probably running via main() in this class.
			// Populate the structure here.
			boolean extractAllFolders = false ;
			if( extractAllFolders )
			{
				addFoldersToExtract( Common.getAllMediaFolders() ) ;
			}
			else
			{
				addFoldersToExtractWithNewThread( Arrays.asList( Common.getPathToToOCR() ) ) ;
			}
		}
	}
	
	protected void addFileToOCRPipeline( final File theFile )
	{
		assert( theFile != null ) ;

		if( null == ocrFilePipeline )
		{
			// Pipeline disabled.
			return ;
		}

		synchronized( ocrFilePipeline )
		{
			ocrFilePipeline.add( theFile ) ;
		}
	}

	protected void addFilesToOCRPipeline( final List< File > theFiles )
	{
		assert( theFiles != null ) ;

		if( null == ocrFilePipeline )
		{
			// Pipeline disabled.
			return ;
		}

		synchronized( ocrFilePipeline )
		{
			ocrFilePipeline.addAll( theFiles ) ;
		}
	}
	
	protected void addFilesToTranscriptionPipeline( final FFmpeg_ProbeResult theProbeResult )
	{
		assert( theProbeResult != null ) ;

		if( null == transcriptionFilePipeline )
		{
			// Pipeline disabled.
			return ;
		}
		
		synchronized( transcriptionFilePipeline )
		{
			createSRTCollection.insertOne( theProbeResult ) ;
//			transcriptionFilePipeline.add( theFile ) ;
		}
		log.info( "Added " + theProbeResult.getFileNameWithPath() + " to transcribe" ) ;
	}
	
	protected void addFilesToTranscriptionPipeline( final List< FFmpeg_ProbeResult > theProbeResults )
	{
		assert( theProbeResults != null ) ;

		if( null == transcriptionFilePipeline )
		{
			// Pipeline disabled.
			return ;
		}
		
		synchronized( transcriptionFilePipeline )
		{
			createSRTCollection.insertMany( theProbeResults ) ;
//			transcriptionFilePipeline.addAll( theFiles ) ;
		}
		log.info( "Added " + theProbeResults.size() + " file(s) to transcribe" ) ;
	}

	/**
	 * Add one or more folders to extract to the default thread.
	 * @param foldersToAdd
	 */
	public void addFoldersToExtract( final List< String > foldersToAdd )
	{
		assert( foldersToAdd != null ) ;

		foldersToExtractByThread.get( 0 ).addAll( foldersToAdd ) ;
	}
	
	public void addFoldersToExtract( final String folderToAdd )
	{
		assert( folderToAdd != null ) ;
		
		addFoldersToExtract( Arrays.asList( folderToAdd ) ) ;
	}

	/**
	 * Add one or more folders to extract to a new thread. Note that this may be the default thread if
	 *  no folders have already been assigned.
	 * @param foldersToAdd
	 */
	public void addFoldersToExtractWithNewThread( final List< String > foldersToAdd )
	{
		assert( foldersToAdd != null ) ;

		List< String > foldersToExtract = new ArrayList< String >() ;
		foldersToExtract.addAll( foldersToAdd ) ;

		foldersToExtractByThread.add( foldersToExtract ) ;
	}

	public void addFoldersToExtractWithNewThread( final String folderToAdd )
	{
		assert( folderToAdd != null ) ;
		
		addFoldersToExtractWithNewThread( Arrays.asList( folderToAdd ) ) ;
	}
	
	public boolean foldersToExtractIsEmpty()
	{
		for( List< String > threadFolderList : foldersToExtractByThread )
		{
			// Finding a single List< String > of folders to extract for a thread is
			// sufficient to the foldersToExtractByThread structure is not empty.
			if( !threadFolderList.isEmpty() )
			{
				return false ;
			}
		}
		return true ;
	}

	/**
	 * Return all folders that will be extracted. Includes folders from all threads.
	 * @return
	 */
	public List< String > getAllFoldersToExtract()
	{
		List< String > allFoldersToExtract = new ArrayList< String >() ;
		for( List< String > theFoldersToExtract : foldersToExtractByThread )
		{
			allFoldersToExtract.addAll( theFoldersToExtract ) ;
		}
		return allFoldersToExtract ;
	}
	
	/**
	 * Return the file at the front of the queue, or null if the queue is empty.
	 * @return
	 */
	protected File getOCRPipelineFile()
	{
		File retMe = null ;
		if( ocrFilePipeline != null )
		{
			synchronized( ocrFilePipeline )
			{
				retMe = ocrFilePipeline.poll() ;
			}
		}
		return retMe ;
	}
	
	protected File getTranscriptionPipelineFile()
	{
		File retMe = null ;
		if( transcriptionFilePipeline != null )
		{
			synchronized( transcriptionFilePipeline )
			{
				retMe = transcriptionFilePipeline.poll() ;
			}
		}
		return retMe ;
	}

	protected boolean pipelineIsEmpty()
	{
		boolean isEmpty = true ;
		if( ocrFilePipeline != null )
		{
			synchronized( ocrFilePipeline )
			{
				isEmpty = ocrFilePipeline.isEmpty() ;
			}
		}
		
		// Only check the transcriptionFilePipeline if the ocrFilePipeline is empty.
		if( isEmpty )
		{
			if( transcriptionFilePipeline != null )
			{
				synchronized( transcriptionFilePipeline )
				{
					isEmpty = transcriptionFilePipeline.isEmpty() ;
				}
			}
		}
		return isEmpty ;
	}

	protected void setOCRPipeline( PriorityBlockingQueue< File > ocrFilePipeline )
	{
		synchronized( ocrFilePipeline )
		{
		this.ocrFilePipeline = ocrFilePipeline ;
		}
	}
	
	protected void setTranscriptionPipeline( PriorityBlockingQueue< File > transcriptionFilePipeline )
	{
		synchronized( transcriptionFilePipeline )
		{
			this.transcriptionFilePipeline = transcriptionFilePipeline ;
		}
	}
}
